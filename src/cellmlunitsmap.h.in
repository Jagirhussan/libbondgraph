/*******************************************************************************

Copyright (C) The University of Auckland

OpenCOR is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenCOR is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://gnu.org/licenses>.

*******************************************************************************/

#pragma once

#include "Exceptions.h"
#include "thirdparty/tinyxml2.h"
#include <algorithm>
#include <cctype>
#include <map>
#include <sstream>
#include <string>
#include <units.hpp>
#include <unordered_map>
#include <vector>
#include <tuple>

//Let the compiler know that the string is defined in a cxx file. The file is generated by cmake.
extern const char *@UNITCELLMLVARNAME@;
namespace BG {

class CellMLUnits
{
private:
    std::unordered_map<std::string, units::precise_unit> dimensions;
    std::unordered_map<std::string, std::string> existingNames;
    std::unordered_map<std::string, std::string> mappedDimensionName;
    std::string predefinedunitsXML;

public:
    inline std::string trim(const std::string &s)
    {
        auto wsfront = std::find_if_not(s.begin(), s.end(), [](int c) { return std::isspace(c); });
        auto wsback = std::find_if_not(s.rbegin(), s.rend(), [](int c) { return std::isspace(c); }).base();
        return (wsback <= wsfront ? std::string() : std::string(wsfront, wsback));
    }

    CellMLUnits()
    {
		predefinedunitsXML = std::string(@UNITCELLMLVARNAME@);
        tinyxml2::XMLDocument doc;
        tinyxml2::XMLPrinter printer;
        std::ostringstream ss;
        if (doc.Parse(predefinedunitsXML.c_str()) == tinyxml2::XML_SUCCESS) {
            tinyxml2::XMLElement *pRootElement = doc.RootElement();
            if (pRootElement != nullptr) {
                //Get 'Units'
                tinyxml2::XMLElement *units = pRootElement->FirstChildElement("units");
                while (units) {
                    std::vector<units::precise_unit> subUnits;
                    std::string unitName = trim(units->Attribute("name"));
                    // Get 'unit' Child
                    tinyxml2::XMLElement *unit = units->FirstChildElement("unit");

                    while (unit) {
                        std::string lunit;
                        std::string expon = "1";
                        std::string prefix = "";
                        for (const tinyxml2::XMLAttribute *attr = unit->FirstAttribute(); attr != 0; attr = attr->Next()) {
                            auto an = trim(attr->Name());
                            auto av = trim(attr->Value());
                            if (an == "units") {
                                //Sometimes units definitions use prior definitions
                                if (dimensions.find(av) != dimensions.end()) {
                                    lunit = units::to_string(dimensions[av]);
                                } else {
                                    lunit = units::to_string(units::unit_from_string(av));
                                }
                            } else if (an == "exponent")
                                expon = av;
                            else if (an == "prefix")
                                prefix = av;
                        }
                        ss.str("");
                        ss.clear();

                        if (expon != "1") {
                            ss << "(" << prefix << " " << lunit << ")^" << expon;
                        } else {
                            ss << prefix << " " << lunit;
                        }
                        subUnits.push_back(units::unit_from_string(ss.str()));
                        unit = unit->NextSiblingElement("unit");
                    }

                    units::precise_unit unitDef = subUnits[0];
                    for (int ix = 1; ix < subUnits.size(); ix++) {
                        unitDef = unitDef * subUnits[ix];
                    }
                    auto mult = unitDef.multiplier();
                    auto baseU = unitDef.base_units();
                    auto preciseunit = units::precise_unit(baseU, mult);
                    dimensions[unitName] = preciseunit;
                    //existingNames[preciseunit] = unitName;
                    existingNames[units::to_string(preciseunit)] = unitName;
                    //std::cout<<unitName<<"\t"<<units::to_string(preciseunit)<<std::endl;
                    // Next Units def
                    units = units->NextSiblingElement("units");
                }
            }
        } else {
            throw BGException("Error creating CellML document from @UNITSCELLMLFILE@");
        }
    };

    
    std::string getPredefinedunitsXML() {
        return predefinedunitsXML;
    }

    std::string
        getUnitName(const std::string &unit)
    {
        //units::precise_unit unit = units::unit_from_string(unitStr);
        if (existingNames.find(unit) != existingNames.end()) {
            return existingNames[unit];
        }
        //WASM doesnt handle exceptions well, so returing a unique string
        return "UNIT_NAME_NOT_FOUND";
        //throw BGException("Name for unit " + unit + " not found");
    }

    std::tuple<std::string,std::string,units::precise_unit> getCellMLDef(const std::string& unit){
        units::precise_unit unitDef = units::unit_from_string_c(unit);
        auto mult = unitDef.multiplier();
        auto baseU = unitDef.base_units();
        std::vector<std::string> unitl;
        std::ostringstream ss;
        ss<<"";
        if(mult!=1.0){
            ss<<"multiplier=\""<<mult<<"\"";
        }
        std::string multiplier = ss.str();
        ss.str("");
        ss.clear();
        if(baseU.meter()!=0){
            std::string mx = multiplier;
            if(baseU.meter()<0){
                mx = "";
            }
            if(baseU.meter()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.meter())+"\" units=\"metre\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"metre\" />");
            }
            if(baseU.meter()>0){
                multiplier = "";
            }            
        }
        if(baseU.kg()!=0){
            std::string mx = multiplier;
            if(baseU.kg()<0){
                mx = "";
            }            
            if(baseU.kg()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.kg())+"\" units=\"kilogram\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"kilogram\" />");
            }
            if(baseU.kg()>0){
                multiplier = "";
            }             
        }
        if(baseU.second()!=0){
            std::string mx = multiplier;
            if(baseU.second()<0){
                mx = "";
            }            
            if(baseU.second()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.second())+"\" units=\"second\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"second\" />");
            }
            if(baseU.second()>0){
                multiplier = "";
            }             
        }
        if(baseU.ampere()!=0){
            std::string mx = multiplier;
            if(baseU.ampere()<0){
                mx = "";
            }            
            if(baseU.ampere()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.ampere())+"\" units=\"ampere\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"ampere\" />");
            }
            if(baseU.ampere()>0){
                multiplier = "";
            }             
        }
        if(baseU.kelvin()!=0){
            std::string mx = multiplier;
            if(baseU.kelvin()<0){
                mx = "";
            }            
            if(baseU.kelvin()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.kelvin())+"\" units=\"kelvin\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"kelvin\" />");
            }
            if(baseU.kelvin()>0){
                multiplier = "";
            }             
        }
        if(baseU.mole()!=0){
            std::string mx = multiplier;
            if(baseU.mole()<0){
                mx = "";
            }            
            if(baseU.mole()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.mole())+"\" units=\"mole\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"mole\" />");
            }
            if(baseU.mole()>0){
                multiplier = "";
            }             
        }        
        if(baseU.candela()!=0){
            std::string mx = multiplier;
            if(baseU.candela()<0){
                mx = "";
            }            
            if(baseU.candela()!=1){
                unitl.push_back("<unit "+mx+" exponent=\""+std::to_string(baseU.candela())+"\" units=\"candela\" />");
            }else{
                unitl.push_back("<unit "+mx+" units=\"candela\" />");
            }
            if(baseU.candela()>0){
                multiplier = "";
            }             
        } 

        std::string uname = unit;
        /*
        auto replace = [&uname](std::string from, std::string to) {
            size_t start_pos = 0;
            while ((start_pos = uname.find(from, start_pos)) != std::string::npos) {
                uname.replace(start_pos, from.length(), to);
                start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
            }
            return uname;
        };
        replace("/","_d_");
        replace("*", "_x_");
        replace("-","_m_");
        replace("^", "p");
        replace("__","_");
        if(isdigit(uname[0])){
            uname = "D"+uname;
        }
        */
        if(mappedDimensionName.find(unit)==mappedDimensionName.end()){
            uname = "Dim"+std::to_string(mappedDimensionName.size()+1);
            mappedDimensionName[unit] = uname;
        }else{
            uname = mappedDimensionName[unit];
        }
        ss<<"<units name=\""<<uname<<"\">"<<std::endl;
        for(auto c: unitl){
            ss<<"\t"<<c<<std::endl;
        }  
        ss<<"</units>"<<std::endl;
        std::string res = ss.str();
        return std::make_tuple(uname,res,unitDef);
    }
};
} // namespace BG
